{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","processBackgroundImage","_toConsumableArray2","_slicedToArray2","processColor","LINEAR_GRADIENT_DIRECTION_REGEX","LINEAR_GRADIENT_ANGLE_UNIT_REGEX","LINEAR_GRADIENT_DEFAULT_DIRECTION","type","DEFAULT_RADIAL_SHAPE","DEFAULT_RADIAL_SIZE","DEFAULT_RADIAL_POSITION","top","left","backgroundImage","result","parseBackgroundImageCSSString","replace","Array","isArray","bgImage","processedColorStops","processColorStops","direction","bgDirection","toLowerCase","test","parsedAngle","getAngleInDegrees","parsedDirection","getDirectionForKeyword","concat","colorStops","shape","size","position","assign","x","y","index","length","colorStop","positions","color","endsWith","push","processedColor","cssString","gradients","bgImageStrings","splitGradients","bgImageString","gradientRegex","match","exec","_match","gradientContent","isRadial","gradient","parseRadialGradientCSSString","parseLinearGradientCSSString","parts","split","firstPartStr","trim","remainingParts","hasShapeSizeOrPositionString","hasExplicitSingleSize","hasExplicitShape","firstPartTokens","token","shift","tokenTrimmed","sizeX","getPositionFromCSSValue","sizeY","right","bottom","t1","t2","token1","token2","horizontalPositions","verticalPositions","includes","t3","t4","token3","token4","keyword1","value1","keyword2","value2","parseColorStopsCSSString","trimmedDirection","colorStopsString","join","stops","prevStop","i","stop","trimmedStop","colorStopParts","position1","position2","normalized","angle","_match2","unit","numericValue","parseFloat","Math","PI","input","current","depth","char"],"sources":["processBackgroundImage.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nimport type {ProcessedColorValue} from './processColor';\nimport type {\n  BackgroundImageValue,\n  RadialGradientPosition,\n  RadialGradientShape,\n  RadialGradientSize,\n} from './StyleSheetTypes';\n\nconst processColor = require('./processColor').default;\n\n// Linear Gradient\nconst LINEAR_GRADIENT_DIRECTION_REGEX =\n  /^to\\s+(?:top|bottom|left|right)(?:\\s+(?:top|bottom|left|right))?/i;\nconst LINEAR_GRADIENT_ANGLE_UNIT_REGEX =\n  /^([+-]?\\d*\\.?\\d+)(deg|grad|rad|turn)$/i;\nconst LINEAR_GRADIENT_DEFAULT_DIRECTION: LinearGradientDirection = {\n  type: 'angle',\n  value: 180,\n};\n\ntype LinearGradientDirection =\n  | {type: 'angle', value: number}\n  | {type: 'keyword', value: string};\n\ntype LinearGradientBackgroundImage = {\n  type: 'linear-gradient',\n  direction: LinearGradientDirection,\n  colorStops: $ReadOnlyArray<{\n    color: ColorStopColor,\n    position: ColorStopPosition,\n  }>,\n};\n\n// Radial Gradient\nconst DEFAULT_RADIAL_SHAPE = 'ellipse';\nconst DEFAULT_RADIAL_SIZE = 'farthest-corner';\n// center\nconst DEFAULT_RADIAL_POSITION: RadialGradientPosition = {\n  top: '50%',\n  left: '50%',\n};\n\ntype RadialGradientBackgroundImage = {\n  type: 'radial-gradient',\n  shape: RadialGradientShape,\n  size: RadialGradientSize,\n  position: RadialGradientPosition,\n  colorStops: $ReadOnlyArray<{\n    color: ColorStopColor,\n    position: ColorStopPosition,\n  }>,\n};\n\n// null color indicate that the transition hint syntax is used. e.g. red, 20%, blue\ntype ColorStopColor = ProcessedColorValue | null;\n// percentage or pixel value\ntype ColorStopPosition = number | string | null;\n\ntype ParsedBackgroundImageValue =\n  | LinearGradientBackgroundImage\n  | RadialGradientBackgroundImage;\n\nexport default function processBackgroundImage(\n  backgroundImage: ?($ReadOnlyArray<BackgroundImageValue> | string),\n): $ReadOnlyArray<ParsedBackgroundImageValue> {\n  let result: $ReadOnlyArray<ParsedBackgroundImageValue> = [];\n  if (backgroundImage == null) {\n    return result;\n  }\n\n  if (typeof backgroundImage === 'string') {\n    result = parseBackgroundImageCSSString(backgroundImage.replace(/\\n/g, ' '));\n  } else if (Array.isArray(backgroundImage)) {\n    for (const bgImage of backgroundImage) {\n      const processedColorStops = processColorStops(bgImage);\n      if (processedColorStops == null) {\n        // If a color stop is invalid, return an empty array and do not apply any gradient. Same as web.\n        return [];\n      }\n\n      if (bgImage.type === 'linear-gradient') {\n        let direction: LinearGradientDirection =\n          LINEAR_GRADIENT_DEFAULT_DIRECTION;\n        const bgDirection =\n          bgImage.direction != null ? bgImage.direction.toLowerCase() : null;\n\n        if (bgDirection != null) {\n          if (LINEAR_GRADIENT_ANGLE_UNIT_REGEX.test(bgDirection)) {\n            const parsedAngle = getAngleInDegrees(bgDirection);\n            if (parsedAngle != null) {\n              direction = {\n                type: 'angle',\n                value: parsedAngle,\n              };\n            } else {\n              // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.\n              return [];\n            }\n          } else if (LINEAR_GRADIENT_DIRECTION_REGEX.test(bgDirection)) {\n            const parsedDirection = getDirectionForKeyword(bgDirection);\n            if (parsedDirection != null) {\n              direction = parsedDirection;\n            } else {\n              // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n              return [];\n            }\n          } else {\n            // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n            return [];\n          }\n        }\n\n        result = result.concat({\n          type: 'linear-gradient',\n          direction,\n          colorStops: processedColorStops,\n        });\n      } else if (bgImage.type === 'radial-gradient') {\n        let shape: RadialGradientShape = DEFAULT_RADIAL_SHAPE;\n        let size: RadialGradientSize = DEFAULT_RADIAL_SIZE;\n        let position: RadialGradientPosition = {...DEFAULT_RADIAL_POSITION};\n\n        if (bgImage.shape != null) {\n          if (bgImage.shape === 'circle' || bgImage.shape === 'ellipse') {\n            shape = bgImage.shape;\n          } else {\n            // If the shape is invalid, return an empty array and do not apply any gradient. Same as web.\n            return [];\n          }\n        }\n\n        if (bgImage.size != null) {\n          if (\n            typeof bgImage.size === 'string' &&\n            (bgImage.size === 'closest-side' ||\n              bgImage.size === 'closest-corner' ||\n              bgImage.size === 'farthest-side' ||\n              bgImage.size === 'farthest-corner')\n          ) {\n            size = bgImage.size;\n          } else if (\n            typeof bgImage.size === 'object' &&\n            bgImage.size.x != null &&\n            bgImage.size.y != null\n          ) {\n            size = {\n              x: bgImage.size.x,\n              y: bgImage.size.y,\n            };\n          } else {\n            // If the size is invalid, return an empty array and do not apply any gradient. Same as web.\n            return [];\n          }\n        }\n\n        if (bgImage.position != null) {\n          position = bgImage.position;\n        }\n\n        result = result.concat({\n          type: 'radial-gradient',\n          shape,\n          size,\n          position,\n          colorStops: processedColorStops,\n        });\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction processColorStops(bgImage: BackgroundImageValue): $ReadOnlyArray<{\n  color: ColorStopColor,\n  position: ColorStopPosition,\n}> | null {\n  const processedColorStops: Array<{\n    color: ColorStopColor,\n    position: ColorStopPosition,\n  }> = [];\n\n  for (let index = 0; index < bgImage.colorStops.length; index++) {\n    const colorStop = bgImage.colorStops[index];\n    const positions = colorStop.positions;\n    // Color transition hint syntax (red, 20%, blue)\n    if (\n      colorStop.color == null &&\n      Array.isArray(positions) &&\n      positions.length === 1\n    ) {\n      const position = positions[0];\n      if (\n        typeof position === 'number' ||\n        (typeof position === 'string' && position.endsWith('%'))\n      ) {\n        processedColorStops.push({\n          color: null,\n          position,\n        });\n      } else {\n        // If a position is invalid, return null and do not apply gradient. Same as web.\n        return null;\n      }\n    } else {\n      const processedColor = processColor(colorStop.color);\n      if (processedColor == null) {\n        // If a color is invalid, return null and do not apply gradient. Same as web.\n        return null;\n      }\n      if (positions != null && positions.length > 0) {\n        for (const position of positions) {\n          if (\n            typeof position === 'number' ||\n            (typeof position === 'string' && position.endsWith('%'))\n          ) {\n            processedColorStops.push({\n              color: processedColor,\n              position,\n            });\n          } else {\n            // If a position is invalid, return null and do not apply gradient. Same as web.\n            return null;\n          }\n        }\n      } else {\n        processedColorStops.push({\n          color: processedColor,\n          position: null,\n        });\n      }\n    }\n  }\n\n  return processedColorStops;\n}\n\nfunction parseBackgroundImageCSSString(\n  cssString: string,\n): $ReadOnlyArray<ParsedBackgroundImageValue> {\n  const gradients = [];\n  const bgImageStrings = splitGradients(cssString);\n\n  for (const bgImageString of bgImageStrings) {\n    const bgImage = bgImageString.toLowerCase();\n    const gradientRegex = /^(linear|radial)-gradient\\(((?:\\([^)]*\\)|[^()])*)\\)/;\n\n    const match = gradientRegex.exec(bgImage);\n    if (match) {\n      const [, type, gradientContent] = match;\n      const isRadial = type.toLowerCase() === 'radial';\n      const gradient = isRadial\n        ? parseRadialGradientCSSString(gradientContent)\n        : parseLinearGradientCSSString(gradientContent);\n\n      if (gradient != null) {\n        gradients.push(gradient);\n      }\n    }\n  }\n  return gradients;\n}\n\nfunction parseRadialGradientCSSString(\n  gradientContent: string,\n): RadialGradientBackgroundImage | null {\n  let shape: RadialGradientShape = DEFAULT_RADIAL_SHAPE;\n  let size: RadialGradientSize = DEFAULT_RADIAL_SIZE;\n  let position: RadialGradientPosition = {...DEFAULT_RADIAL_POSITION};\n\n  // split the content by commas, but not if inside parentheses (for color values)\n  const parts = gradientContent.split(/,(?![^(]*\\))/);\n  // first part may contain shape, size, and position\n  // [ <radial-shape> || <radial-size> ]? [ at <position> ]?\n  const firstPartStr = parts[0].trim();\n  const remainingParts = [...parts];\n  let hasShapeSizeOrPositionString = false;\n  let hasExplicitSingleSize = false;\n  let hasExplicitShape = false;\n  const firstPartTokens = firstPartStr.split(/\\s+/);\n\n  // firstPartTokens is the shape, size, and position\n  while (firstPartTokens.length > 0) {\n    let token = firstPartTokens.shift();\n    if (token == null) {\n      continue;\n    }\n    let tokenTrimmed = token.toLowerCase().trim();\n\n    if (tokenTrimmed === 'circle' || tokenTrimmed === 'ellipse') {\n      shape = tokenTrimmed === 'circle' ? 'circle' : 'ellipse';\n      hasShapeSizeOrPositionString = true;\n      hasExplicitShape = true;\n    } else if (\n      tokenTrimmed === 'closest-corner' ||\n      tokenTrimmed === 'farthest-corner' ||\n      tokenTrimmed === 'closest-side' ||\n      tokenTrimmed === 'farthest-side'\n    ) {\n      size = tokenTrimmed;\n      hasShapeSizeOrPositionString = true;\n    } else if (tokenTrimmed.endsWith('px') || tokenTrimmed.endsWith('%')) {\n      let sizeX = getPositionFromCSSValue(tokenTrimmed);\n      if (sizeX == null) {\n        // If a size is invalid, return null and do not apply any gradient. Same as web.\n        return null;\n      }\n      if (typeof sizeX === 'number' && sizeX < 0) {\n        // If a size is invalid, return null and do not apply any gradient. Same as web.\n        return null;\n      }\n      hasShapeSizeOrPositionString = true;\n      size = {x: sizeX, y: sizeX};\n      token = firstPartTokens.shift();\n      if (token == null) {\n        hasExplicitSingleSize = true;\n        continue;\n      }\n      tokenTrimmed = token.toLowerCase().trim();\n      if (tokenTrimmed.endsWith('px') || tokenTrimmed.endsWith('%')) {\n        const sizeY = getPositionFromCSSValue(tokenTrimmed);\n        if (sizeY == null) {\n          // If a size is invalid, return null and do not apply any gradient. Same as web.\n          return null;\n        }\n        if (typeof sizeY === 'number' && sizeY < 0) {\n          // If a size is invalid, return null and do not apply any gradient. Same as web.\n          return null;\n        }\n        size = {x: sizeX, y: sizeY};\n      } else {\n        hasExplicitSingleSize = true;\n      }\n    } else if (tokenTrimmed === 'at') {\n      let top: string | number;\n      let left: string | number;\n      let right: string | number;\n      let bottom: string | number;\n      hasShapeSizeOrPositionString = true;\n\n      if (firstPartTokens.length === 0) {\n        // If 'at' is not followed by a position, return null and do not apply any gradient. Same as web.\n        return null;\n      }\n\n      // 1. [ left | center | right | top | bottom | <length-percentage> ]\n      if (firstPartTokens.length === 1) {\n        token = firstPartTokens.shift();\n        if (token == null) {\n          // If 'at' is not followed by a position, return null and do not apply any gradient. Same as web.\n          return null;\n        }\n        tokenTrimmed = token.toLowerCase().trim();\n        if (tokenTrimmed === 'left') {\n          left = '0%';\n          top = '50%';\n        } else if (tokenTrimmed === 'center') {\n          left = '50%';\n          top = '50%';\n        } else if (tokenTrimmed === 'right') {\n          left = '100%';\n          top = '50%';\n        } else if (tokenTrimmed === 'top') {\n          left = '50%';\n          top = '0%';\n        } else if (tokenTrimmed === 'bottom') {\n          left = '50%';\n          top = '100%';\n        } else if (tokenTrimmed.endsWith('px') || tokenTrimmed.endsWith('%')) {\n          const value = getPositionFromCSSValue(tokenTrimmed);\n          if (value == null) {\n            // If a position is invalid, return null and do not apply any gradient. Same as web.\n            return null;\n          }\n          left = value;\n          top = '50%';\n        }\n      }\n\n      if (firstPartTokens.length === 2) {\n        const t1 = firstPartTokens.shift();\n        const t2 = firstPartTokens.shift();\n        if (t1 == null || t2 == null) {\n          // If a position is invalid, return null and do not apply any gradient. Same as web.\n          return null;\n        }\n\n        const token1 = t1.toLowerCase().trim();\n        const token2 = t2.toLowerCase().trim();\n\n        // 2. [ left | center | right ] && [ top | center | bottom ]\n        const horizontalPositions = ['left', 'center', 'right'];\n        const verticalPositions = ['top', 'center', 'bottom'];\n\n        if (\n          horizontalPositions.includes(token1) &&\n          verticalPositions.includes(token2)\n        ) {\n          left =\n            token1 === 'left' ? '0%' : token1 === 'center' ? '50%' : '100%';\n          top = token2 === 'top' ? '0%' : token2 === 'center' ? '50%' : '100%';\n        } else if (\n          verticalPositions.includes(token1) &&\n          horizontalPositions.includes(token2)\n        ) {\n          left =\n            token2 === 'left' ? '0%' : token2 === 'center' ? '50%' : '100%';\n          top = token1 === 'top' ? '0%' : token1 === 'center' ? '50%' : '100%';\n        }\n        // 3. [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]\n        else {\n          if (token1 === 'left') {\n            left = '0%';\n          } else if (token1 === 'center') {\n            left = '50%';\n          } else if (token1 === 'right') {\n            left = '100%';\n          } else if (token1.endsWith('px') || token1.endsWith('%')) {\n            const value = getPositionFromCSSValue(token1);\n            if (value == null) {\n              // If a position is invalid, return null and do not apply any gradient. Same as web.\n              return null;\n            }\n            left = value;\n          } else {\n            // If a position is invalid, return null and do not apply any gradient. Same as web.\n            return null;\n          }\n\n          if (token2 === 'top') {\n            top = '0%';\n          } else if (token2 === 'center') {\n            top = '50%';\n          } else if (token2 === 'bottom') {\n            top = '100%';\n          } else if (token2.endsWith('px') || token2.endsWith('%')) {\n            const value = getPositionFromCSSValue(token2);\n            if (value == null) {\n              // If a position is invalid, return null and do not apply any gradient. Same as web.\n              return null;\n            }\n            top = value;\n          } else {\n            // If a position is invalid, return null and do not apply any gradient. Same as web.\n            return null;\n          }\n        }\n      }\n\n      // 4. [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ]\n      if (firstPartTokens.length === 4) {\n        const t1 = firstPartTokens.shift();\n        const t2 = firstPartTokens.shift();\n        const t3 = firstPartTokens.shift();\n        const t4 = firstPartTokens.shift();\n\n        if (t1 == null || t2 == null || t3 == null || t4 == null) {\n          // If a position is invalid, return null and do not apply any gradient. Same as web.\n          return null;\n        }\n        const token1 = t1.toLowerCase().trim();\n        const token2 = t2.toLowerCase().trim();\n        const token3 = t3.toLowerCase().trim();\n        const token4 = t4.toLowerCase().trim();\n        const keyword1 = token1;\n        const value1 = getPositionFromCSSValue(token2);\n        const keyword2 = token3;\n        const value2 = getPositionFromCSSValue(token4);\n        if (value1 == null || value2 == null) {\n          // If a position is invalid, return null and do not apply any gradient. Same as web.\n          return null;\n        }\n\n        if (keyword1 === 'left') {\n          left = value1;\n        } else if (keyword1 === 'right') {\n          right = value1;\n        } else if (keyword1 === 'top') {\n          top = value1;\n        } else if (keyword1 === 'bottom') {\n          bottom = value1;\n        } else {\n          // If a position is invalid, return null and do not apply any gradient. Same as web.\n          return null;\n        }\n\n        if (keyword2 === 'left') {\n          left = value2;\n        } else if (keyword2 === 'right') {\n          right = value2;\n        } else if (keyword2 === 'top') {\n          top = value2;\n        } else if (keyword2 === 'bottom') {\n          bottom = value2;\n        } else {\n          // If a position is invalid, return null and do not apply any gradient. Same as web.\n          return null;\n        }\n      }\n\n      if (top != null && left != null) {\n        position = {\n          top,\n          left,\n        };\n      } else if (bottom != null && right != null) {\n        position = {\n          bottom,\n          right,\n        };\n      } else if (top != null && right != null) {\n        position = {\n          top,\n          right,\n        };\n      } else if (bottom != null && left != null) {\n        position = {\n          bottom,\n          left,\n        };\n      } else {\n        // If a position is invalid, return null and do not apply any gradient. Same as web.\n        return null;\n      }\n      // 'at' comes at the end of first part of radial gradient syntax;\n      break;\n    }\n\n    // if there is no shape, size, or position string found in first token, break\n    // if might be a color stop\n    if (!hasShapeSizeOrPositionString) {\n      break;\n    }\n  }\n\n  if (hasShapeSizeOrPositionString) {\n    remainingParts.shift();\n\n    if (!hasExplicitShape && hasExplicitSingleSize) {\n      shape = 'circle';\n    }\n\n    if (hasExplicitSingleSize && hasExplicitShape && shape === 'ellipse') {\n      // If a single size is explicitly set and the shape is an ellipse, return null and do not apply any gradient. Same as web.\n      return null;\n    }\n  }\n\n  const colorStops = parseColorStopsCSSString(remainingParts);\n  if (colorStops == null) {\n    // If color stops are invalid, return null and do not apply any gradient. Same as web.\n    return null;\n  }\n\n  return {\n    type: 'radial-gradient',\n    shape,\n    size,\n    position,\n    colorStops,\n  };\n}\n\nfunction parseLinearGradientCSSString(\n  gradientContent: string,\n): LinearGradientBackgroundImage | null {\n  const parts = gradientContent.split(',');\n  let direction: LinearGradientDirection = LINEAR_GRADIENT_DEFAULT_DIRECTION;\n  const trimmedDirection = parts[0].trim().toLowerCase();\n\n  if (LINEAR_GRADIENT_ANGLE_UNIT_REGEX.test(trimmedDirection)) {\n    const parsedAngle = getAngleInDegrees(trimmedDirection);\n    if (parsedAngle != null) {\n      direction = {\n        type: 'angle',\n        value: parsedAngle,\n      };\n      parts.shift();\n    } else {\n      // If an angle is invalid, return null and do not apply any gradient. Same as web.\n      return null;\n    }\n  } else if (LINEAR_GRADIENT_DIRECTION_REGEX.test(trimmedDirection)) {\n    const parsedDirection = getDirectionForKeyword(trimmedDirection);\n    if (parsedDirection != null) {\n      direction = parsedDirection;\n      parts.shift();\n    } else {\n      // If a direction is invalid, return null and do not apply any gradient. Same as web.\n      return null;\n    }\n  }\n\n  const colorStops = parseColorStopsCSSString(parts);\n  if (colorStops == null) {\n    // If a color stop is invalid, return null and do not apply any gradient. Same as web.\n    return null;\n  }\n\n  return {\n    type: 'linear-gradient',\n    direction,\n    colorStops,\n  };\n}\n\nfunction parseColorStopsCSSString(parts: Array<string>): Array<{\n  color: ColorStopColor,\n  position: ColorStopPosition,\n}> | null {\n  const colorStopsString = parts.join(',');\n  const colorStops: Array<{\n    color: ColorStopColor,\n    position: ColorStopPosition,\n  }> = [];\n  // split by comma, but not if it's inside a parentheses. e.g. red, rgba(0, 0, 0, 0.5), green => [\"red\", \"rgba(0, 0, 0, 0.5)\", \"green\"]\n  const stops = colorStopsString.split(/,(?![^(]*\\))/);\n  let prevStop = null;\n  for (let i = 0; i < stops.length; i++) {\n    const stop = stops[i];\n    const trimmedStop = stop.trim().toLowerCase();\n    // Match function like pattern or single words\n    const colorStopParts = trimmedStop.match(/\\S+\\([^)]*\\)|\\S+/g);\n    if (colorStopParts == null) {\n      // If a color stop is invalid, return null and do not apply any gradient. Same as web.\n      return null;\n    }\n    // Case 1: [color, position, position]\n    if (colorStopParts.length === 3) {\n      const color = colorStopParts[0];\n      const position1 = getPositionFromCSSValue(colorStopParts[1]);\n      const position2 = getPositionFromCSSValue(colorStopParts[2]);\n      const processedColor = processColor(color);\n      if (processedColor == null) {\n        // If a color is invalid, return null and do not apply any gradient. Same as web.\n        return null;\n      }\n\n      if (position1 == null || position2 == null) {\n        // If a position is invalid, return null and do not apply any gradient. Same as web.\n        return null;\n      }\n\n      colorStops.push({\n        color: processedColor,\n        position: position1,\n      });\n      colorStops.push({\n        color: processedColor,\n        position: position2,\n      });\n    }\n    // Case 2: [color, position]\n    else if (colorStopParts.length === 2) {\n      const color = colorStopParts[0];\n      const position = getPositionFromCSSValue(colorStopParts[1]);\n      const processedColor = processColor(color);\n      if (processedColor == null) {\n        // If a color is invalid, return null and do not apply any gradient. Same as web.\n        return null;\n      }\n      if (position == null) {\n        // If a position is invalid, return null and do not apply any gradient. Same as web.\n        return null;\n      }\n      colorStops.push({\n        color: processedColor,\n        position,\n      });\n    }\n    // Case 3: [color]\n    // Case 4: [position] => transition hint syntax\n    else if (colorStopParts.length === 1) {\n      const position = getPositionFromCSSValue(colorStopParts[0]);\n      if (position != null) {\n        // handle invalid transition hint syntax. transition hint syntax must have color before and after the position. e.g. red, 20%, blue\n        if (\n          (prevStop != null &&\n            prevStop.length === 1 &&\n            getPositionFromCSSValue(prevStop[0]) != null) ||\n          i === stops.length - 1 ||\n          i === 0\n        ) {\n          // If the last stop is a transition hint syntax, return null and do not apply any gradient. Same as web.\n          return null;\n        }\n        colorStops.push({\n          color: null,\n          position,\n        });\n      } else {\n        const processedColor = processColor(colorStopParts[0]);\n        if (processedColor == null) {\n          // If a color is invalid, return null and do not apply any gradient. Same as web.\n          return null;\n        }\n        colorStops.push({\n          color: processedColor,\n          position: null,\n        });\n      }\n    } else {\n      // If a color stop is invalid, return null and do not apply any gradient. Same as web.\n      return null;\n    }\n    prevStop = colorStopParts;\n  }\n\n  return colorStops;\n}\n\nfunction getDirectionForKeyword(direction?: string): ?LinearGradientDirection {\n  if (direction == null) {\n    return null;\n  }\n  // Remove extra whitespace\n  const normalized = direction.replace(/\\s+/g, ' ').toLowerCase();\n\n  switch (normalized) {\n    case 'to top':\n      return {type: 'angle', value: 0};\n    case 'to right':\n      return {type: 'angle', value: 90};\n    case 'to bottom':\n      return {type: 'angle', value: 180};\n    case 'to left':\n      return {type: 'angle', value: 270};\n    case 'to top right':\n    case 'to right top':\n      return {type: 'keyword', value: 'to top right'};\n    case 'to bottom right':\n    case 'to right bottom':\n      return {type: 'keyword', value: 'to bottom right'};\n    case 'to top left':\n    case 'to left top':\n      return {type: 'keyword', value: 'to top left'};\n    case 'to bottom left':\n    case 'to left bottom':\n      return {type: 'keyword', value: 'to bottom left'};\n    default:\n      return null;\n  }\n}\n\nfunction getAngleInDegrees(angle?: string): ?number {\n  if (angle == null) {\n    return null;\n  }\n  const match = angle.match(LINEAR_GRADIENT_ANGLE_UNIT_REGEX);\n  if (!match) {\n    return null;\n  }\n\n  const [, value, unit] = match;\n\n  const numericValue = parseFloat(value);\n  switch (unit) {\n    case 'deg':\n      return numericValue;\n    case 'grad':\n      return numericValue * 0.9; // 1 grad = 0.9 degrees\n    case 'rad':\n      return (numericValue * 180) / Math.PI;\n    case 'turn':\n      return numericValue * 360; // 1 turn = 360 degrees\n    default:\n      return null;\n  }\n}\n\nfunction getPositionFromCSSValue(position: string) {\n  if (position.endsWith('px')) {\n    return parseFloat(position);\n  }\n\n  if (position.endsWith('%')) {\n    return position;\n  }\n}\n\nfunction splitGradients(input: string) {\n  const result = [];\n  let current = '';\n  let depth = 0;\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n\n    if (char === '(') {\n      depth++;\n    } else if (char === ')') {\n      depth--;\n    } else if (char === ',' && depth === 0) {\n      result.push(current.trim());\n      current = '';\n      continue;\n    }\n\n    current += char;\n  }\n\n  if (current.trim() !== '') {\n    result.push(current.trim());\n  }\n\n  return result;\n}\n"],"mappings":"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","ignoreList":[]}